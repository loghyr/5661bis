<!-- Copyright (C) The IETF Trust (2011) -->
<!-- Copyright (C) The Internet Society (2011) -->

  <section anchor="op_RENAME" title="Operation 29: RENAME - Rename Directory Entry">
    <section toc='exclude' anchor="ss:op_RENAME:A" title="ARGUMENT">
      <?rfc include='autogen/rename_args.xml'?>
    </section>

    <section toc='exclude' anchor="ss:op_RENAME:R" title="RESULT">
      <?rfc include='autogen/rename_res.xml'?>
    </section>

    <section toc='exclude' anchor="ss:op_RENAME:D" title="DESCRIPTION">
      <t>
        The RENAME operation renames the object identified by oldname in the
        source directory corresponding to the saved filehandle, as set by the
        SAVEFH operation, to newname in the target directory corresponding to
        the current filehandle.  The operation is required to be atomic to
        the client.  Source and target directories MUST reside on the same
        file system on the server.  On success, the current filehandle will
        continue to be the target directory.
      </t>

      <t>
        If the target directory already contains an entry with the name
        newname, the source object MUST be compatible with the target: either
        both are non-directories or both are directories and the target MUST
        be empty.  If compatible, the existing target is removed before the
        rename occurs or, preferably, the target is removed atomically as
        part of the rename.  See <xref target="ss:op_REMOVE:I" /> for client and server
        actions whenever a target is removed.  Note however that when the
        removal is performed atomically with the rename, certain parts of the
        removal described there are integrated with the rename.  For example,
        notification of the removal will not be via a NOTIFY4_REMOVE_ENTRY
        but will be indicated as part of the NOTIFY4_ADD_ENTRY or
        NOTIFY4_RENAME_ENTRY generated by the rename.
      </t>

      <t>
        If the source object and the target are not compatible or if the
        target is a directory but not empty, the server will return the error
        NFS4ERR_EXIST.
      </t>

      <t>
        If oldname and newname both refer to the same file (e.g., they might
        be hard links of each other), then unless the file is open (see
        <xref target="ss:op_RENAME:I" />), RENAME MUST perform no action and return NFS4_OK.
      </t>

      <t>
        For both directories involved in the RENAME, the server returns
        change_info4 information.  With the atomic field of the change_info4
        data type, the server will indicate if the before and after change
        attributes were obtained atomically with respect to the rename.
      </t>

      <t>
        If oldname refers to a named attribute and the saved and current
        filehandles refer to different file system objects, the server will
        return NFS4ERR_XDEV just as if the saved and current filehandles
        represented directories on different file systems.
      </t>

      <t>
        If oldname or newname has a length of zero, or if oldname or newname
        does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be
        returned.
      </t>
    </section>

    <section toc='exclude' anchor="ss:op_RENAME:I" title="IMPLEMENTATION">
      <t>
        The server MAY impose restrictions on the RENAME operation such that
        RENAME may not be done when the file being renamed is open or when
        that open is done by particular protocols, or with particular options
        or access modes.  Similar restrictions may be applied when a file
        exists with the target name and is open.  When RENAME is rejected
        because of such restrictions, the error NFS4ERR_FILE_OPEN is
        returned.
      </t>

      <t>
        When oldname and rename refer to the same file and that file is open
        in a fashion such that RENAME would normally be rejected with
        NFS4ERR_FILE_OPEN if oldname and newname were different files, then
        RENAME SHOULD be rejected with NFS4ERR_FILE_OPEN.
      </t>

      <t>
        If a server does implement such restrictions and those restrictions
        include cases of NFSv4 opens preventing successful execution of a
        rename, the server needs to recall any delegations that could hide
        the existence of opens relevant to that decision.  This is because
        when a client holds a delegation, the server might not have an
        accurate account of the opens for that client, since the client may
        execute OPENs and CLOSEs locally.  The RENAME operation need only be
        delayed until a definitive result can be obtained.  For example, if
        there are multiple delegations and one of them establishes an open
        whose presence would prevent the rename, given the server's
        semantics, NFS4ERR_FILE_OPEN may be returned to the caller as soon as
        that delegation is returned without waiting for other delegations to
        be returned.  Similarly, if such opens are not associated with
        delegations, NFS4ERR_FILE_OPEN can be returned immediately with no
        delegation recall being done.
      </t>

      <t>
        If the current filehandle or the saved filehandle designates a
        directory for which another client holds a directory delegation,
        then, unless the situation can be resolved by sending a notification,
        the delegation MUST be recalled, and the operation cannot proceed
        until the delegation is returned or revoked.  Except where this
        happens very quickly, one or more NFS4ERR_DELAY errors will be
        returned to requests made while delegation remains outstanding.
      </t>

      <t>
        When the current and saved filehandles are the same and they
        designate a directory for which one or more directory delegations
        exist, then, when those delegations request such notifications, a
        notification of type NOTIFY4_RENAME_ENTRY will be generated as a
        result of this operation.  When oldname and rename refer to the same
        file, no notification is generated (because, as <xref target="ss:op_RENAME:D" />
        states, the server MUST take no action).  When a file is removed
        because it has the same name as the target, if that removal is done
        atomically with the rename, a NOTIFY4_REMOVE_ENTRY notification will
        not be generated.  Instead, the deletion of the file will be reported
        as part of the NOTIFY4_RENAME_ENTRY notification.
      </t>

      <t>
        When the current and saved filehandles are not the same:
      </t>

      <t>
        <list style='symbols'>
          <t>
            If the current filehandle designates a directory for which one or
            more directory delegations exist, then, when those delegations
            request such notifications, NOTIFY4_ADD_ENTRY will be generated as
            a result of this operation.  When a file is removed because it has
            the same name as the target, if that removal is done atomically
            with the rename, a NOTIFY4_REMOVE_ENTRY notification will not be
            generated.  Instead, the deletion of the file will be reported as
            part of the NOTIFY4_ADD_ENTRY notification.
          </t>

          <t>
            If the saved filehandle designates a directory for which one or
            more directory delegations exist, then, when those delegations
            request such notifications, NOTIFY4_REMOVE_ENTRY will be generated
            as a result of this operation.
          </t>
        </list>
      </t>

      <t>
        If the object being renamed has file delegations held by clients
        other than the one doing the RENAME, the delegations MUST be
        recalled, and the operation cannot proceed until each such delegation
        is returned or revoked.  Note that in the case of multiply linked
        files, the delegation recall requirement applies even if the
        delegation was obtained through a different name than the one being
        renamed.  In all cases in which delegations are recalled, the server
        is likely to return one or more NFS4ERR_DELAY errors while the
        delegation(s) remains outstanding, although it might not do that if
        the delegations are returned quickly.
      </t>

      <t>
        The RENAME operation must be atomic to the client.  The statement
        "source and target directories MUST reside on the same file system on
        the server" means that the fsid fields in the attributes for the
        directories are the same.  If they reside on different file systems,
        the error NFS4ERR_XDEV is returned.
      </t>

      <t>
        Based on the value of the fh_expire_type attribute for the object,
        the filehandle may or may not expire on a RENAME.  However, server
        implementors are strongly encouraged to attempt to keep filehandles
        from expiring in this fashion.
      </t>

      <t>
        On some servers, the file names "." and ".." are illegal as either
        oldname or newname, and will result in the error NFS4ERR_BADNAME.  In
        addition, on many servers the case of oldname or newname being an
        alias for the source directory will be checked for.  Such servers
        will return the error NFS4ERR_INVAL in these cases.
      </t>

      <t>
        If either of the source or target filehandles are not directories,
        the server will return NFS4ERR_NOTDIR.
      </t>
    </section>
  </section>

